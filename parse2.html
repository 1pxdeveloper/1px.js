<meta charset="utf-8"/>
<script>

	var tokenize = function() {
		var regex = [
			["ws", /\s+/],
			["name", /[^0-9\s!-#%-\/:-@\[-^`{-~][^\s!-#%-\/:-@\[-^`{-~]*/],
			["operator", /[.\[\](){}:;?~,]|===|!==|\+\+|--|&&|\|\||(?:>>>|<<|>>|[-+*\/%=<>!&|^])=?/],
			["number", /0[xX][0-9a-fA-F]+|[0-9]*\.[0-9]+|[0-9]+/],
			["string", /"(?:\\.|[^"])*"|'(?:\\.|[^'])*'/],
			["regexp", /\/(?:\\.|[^\/])+\/\w*/],
			["unknown", /./]
		];

		var len = regex.length;
		var regex_string = regex.map(function(row) { return "(" + row[1].source + ")" }).join("|");
		var regexp = new RegExp(regex_string, "g");

		return function(script) {
			var result = [];
			var token = {};

			script.replace(regexp, function(value) {

				/// skip ws
				if (arguments[1] !== undefined) {
					token = {};
					return value;
				}

				/// name
//				if (arguments[len] !== undefined && token.type === "name") {
//					token.value += value;
//					return value;
//				}

				for (var i = 1; i < len; i++) {
					if (arguments[i + 1] === undefined) {
						continue;
					}

					token = {};
					token.type = regex[i][0];
					token.value = value;
					result.push(token);
					return value;
				}

				return value;
			});

			return result;
		}
	}();

//	for (var i = 33; i < 200; i++) {
//		console.log(i, String.fromCharCode(i));
//	}

	var symbol_table = {};
	var token;
	var tokens;
	var token_nr;
	var scope;

	function itself() {
		return this;
	}

	function error(t, message) {
		t.name = "SyntaxError";
		t.message = message;
		throw t;
	}

	function advance(id) {
		var a, o, t, v;

		if (id && token.id !== id) {
			return error(token, "Expected '" + id + "'.");
		}

		if (token_nr >= tokens.length) {
			token = symbol_table["(end)"];
			return;
		}

		t = tokens[token_nr++];

		v = t.value;
		a = t.type;

		if (a === "name") {
			o = symbol_table["(name)"];
		}
		else if (a === "operator") {
			o = symbol_table[v];
			if (!o) {
				error(t, "Unknown operator.");
			}
		}
		else if (a === "string" || a === "number") {
			o = symbol_table["(literal)"];
			a = "literal";
		}
		else {
			error(t, "Unexpected token.");
		}

		token = Object.create(o);
		token.type = t.type;
		token.value = v;
		token.arity = a;
		return token;
	}

	function expression(rbp) {
		var left;
		var t = token;

		advance();
		left = t.nud();
		while(rbp < token.lbp) {
			t = token;
			advance();
			left = t.led(left);
		}
		return left;
	}

	var original_symbol = {
		nud: function() {
			error(this, "Undefined.");
		},
		led: function() {
			error(this, "Missing operator.");
		},
		calc: function() {
			return this.calcFn[this.arity].call(this, this.first, this.second);
		}
	};

	function symbol(id, bp) {
		var s = symbol_table[id];
		bp = bp || 0;
		if (s) {
			if (bp >= s.lbp) {
				s.lbp = bp;
			}
		}
		else {
			s = Object.create(original_symbol);
			s.id = s.value = id;
			s.lbp = bp;
			s.calcFn = s.calcFn || {};
			symbol_table[id] = s;
		}
		return s;
	}

	function constant(s, v) {
		var x = symbol(s);
		x.nud = function() {
//			scope.reserve(this);
			this.value = symbol_table[this.id].value;
			this.arity = "literal";
			return this;
		};
		x.value = v;
		return x;
	}

	function infix(id, bp, led, calc) {
		var s = symbol(id, bp);
		s.led = led || function(left) {
			this.first = left;
			this.second = expression(bp); /// bp? 따로 함수로 뺄수 있는지 확인해보자..
			this.arity = "binary";
			return this;
		};

		s.calcFn["binary"] = calc;
		return s;
	}

	function prefix(id, nud, calc) {
		var s = symbol(id);
		s.nud = nud || prefix.nud;
		s.calcFn["unary"] = calc;
		return s;
	}
	prefix.nud = function() {
		this.first = expression(80);
		this.arity = "unary";
		return this;
	};



	constant("undefined", undefined);
	constant("null", null);
	constant("true", true);
	constant("false", false);
	constant("Infinity", Infinity);
	constant("-Infinity", -Infinity);
	constant("NaN", NaN);
	constant("Math", Math);

	symbol("(end)");
	symbol("(name)").nud = itself;
	symbol("(name)").calcFn = {
		"name": function() {
			console.log(this);
			return $scope[this.value];
		}
	};

	symbol("(literal)").nud = itself;
	symbol("(literal)").calcFn = {
		"literal": function() {
			console.log(this);

			if (this.type === "number") return +this.value;
			return this.value;
		}
	};

	symbol(":");
	symbol(",");
	symbol(")");
	symbol("]");
	symbol("}");

	symbol("this").nud = function() {
		this.arity = "this";
		return this;
	};

	infix("+", 60, null, function(a, b) {
		return a.calc() + b.calc();
	});

	infix("-", 60, null, function(a, b) {
		return a.calc() - b.calc();
	});

	infix("*", 70, null, function(a, b) {
		return a.calc() * b.calc();
	});

	infix("/", 70, null, function(a, b) {
		return a.calc() / b.calc();
	});

	infix("%", 70, null, function(a, b) {
		return a.calc() % b.calc();
	});

	infix(".", 90, function(left) {
		this.first = left;

		if (token.arity !== "name") {
			error(token, "Expected a property name.");
		}
		token.arity = "literal";
		this.second = token;
		this.arity = "binary";
		advance();
		return this;

	}, function(a, b) {
		var obj = a.calc();
		return obj && obj[b.value];
	});

	prefix("+", null, function(a) {
		return +a.calc();
	});

	prefix("-", null, function(a) {
		return -a.calc();
	});

	prefix("!", null, function(a) {
		return !a.calc();
	});

	prefix("~", null, function(a) {
		return ~a.calc();
	});

	prefix("(", function() {
		var e = expression(0);
		advance(")");
		return e;
	});

	prefix("[", function() {
		var a = [];
		if (token.id !== "]") {
			while(true) {
				a.push(expression(0));
				if (token.id !== ",") {
					break;
				}
				advance(",");
			}
		}
		advance("]");
		this.first = a;
		this.arity = "unary";
		return this;

	}, function(a) {
		return a.map(calc);
	});

	function calc(v) {
		return v.calc();
	}

/*
 	+ - * / %
	! ~

	{}()[] . ; ,

 	< > <= >= == != === !==

	&& ||

	++ --

	? :

	= += -= >>= >>>= &= /= *= %= <<= ^= |=
 */


	function parse(source) {
		tokens = tokenize(source);
		token_nr = 0;
		advance();
		var s = expression(0);
		advance("(end)");
		return s;
	}

	function value(a) {
		return a.value;
	}

	var $scope = {
		x: 200,
		foo: {
			bar: 500,
			baz: {
				x: 100,
				y: 200
			}
		}
	};

	var source = "2 * x + abc.def + (100 + foo.baz.x * 2) / 1";
	var root = parse(source);
	console.log(root);
	console.log(root.calc());

	with($scope)console.log(eval(source));




</script>