<meta charset="utf-8"/>

<script>
	var tokenize = function() {
		var regex = [
			["ws", /\s+/],
			["name", /[^0-9\s\u0000-\u0023\u0025-\u002f\u003a-\u0040\u005b-\u005e\u0060\u007b-\u00a0\u200C\u200D][^\s\u0000-\u0023\u0025-\u002f\u003a-\u0040\u005b-\u005e\u0060\u007b-\u00a0\u200C\u200D]*/],
			["operator", /===|!==|==|!=|<=|>=|&&|\|\|/],
			["operator", /\+\+|--|(?:>>>|>>|<<|[-+*\/%&^|])=?/],
			["number", /0[xX][0-9a-fA-F]+|[0-9]*\.[0-9]+|[0-9]+/],
			["string", /"(?:\\.|[^"])*"|'(?:\\.|[^'])*'/],
			["regexp", /\/(?:\\.|[^\/])+\/\w*/],
			["operator", /./]
		];

		var len = regex.length;
		var regex_string = regex.map(function(row) { return "(" + row[1].source + ")" }).join("|");
		var regexp = new RegExp(regex_string, "g");

		return function(script) {
			var result = [];
			var token = {};

			script.replace(regexp, function(value) {

				/// skip ws
				if (arguments[1] !== undefined) {
					token = {};
					return value;
				}

				for (var i = 1; i < len; i++) {
					if (arguments[i + 1] === undefined) {
						continue;
					}

					token = {};
					token.type = regex[i][0];
					token.value = value;
					result.push(token);
					return value;
				}

				return value;
			});

			return result;
		}
	}();

	var symbol_table = {};
	var token;
	var tokens;
	var token_nr;
	var scope;

	function error(t, message) {
		t.name = "SyntaxError";
		t.message = message;
		throw t;
	}

	function itself() {
		return this;
	}

	function advance(id) {
		var a, o, t, v;

		if (id && token.id !== id) {
			return error(token, "Expected '" + id + "'.");
		}

		if (token_nr >= tokens.length) {
			token = symbol_table["(end)"];
			return;
		}

		t = tokens[token_nr++];
		a = t.type;
		v = t.value;

		if (a === "name") {
			o = symbol_table[v] || symbol_table["(name)"];
		}
		else if (a === "operator") {
			o = symbol_table[v];
			if (!o) {
				error(t, "Unknown operator.");
			}
		}
		else if (a === "string") {
			o = symbol_table["(literal)"];
			a = "literal";
		}
		else if (a === "number") {
			o = symbol_table["(literal)"];
			a = "literal";
			v = +v;
		}
		else {
			error(t, "Unexpected token.");
		}

		token = Object.create(o);
		token.value = v;
		token.arity = a;

		return token;
	}

	function expression(rbp) {
		var left;
		var t = token;

		advance();
		left = t.nud();
		while(rbp < token.lbp) {
			t = token;
			advance();
			left = t.led(left);
		}
		return left;
	}

	var original_symbol = {
		nud: function() {
			error(this, "Undefined.");
		},
		led: function() {
			error(this, "Missing operator.");
		},
		calc: function() {
			return this.calcFn[this.arity].call(this, this.first, this.second, this.third);
		}
	};

	function symbol(id, bp) {
		var s = symbol_table[id];
		bp = bp || 0;
		if (s) {
			if (bp >= s.lbp) {
				s.lbp = bp;
			}
		}
		else {
			s = Object.create(original_symbol);
			s.id = s.value = id;
			s.lbp = bp;
			s.calcFn = s.calcFn || {};
			symbol_table[id] = s;
		}
		return s;
	}

	function constant(s, v) {
		var x = symbol(s);
		x.nud = function() {
			this.arity = "constant";
			return this;
		};
		x.value = v;
		x.calc = function() { return v; };
		return x;
	}

	function infix(id, bp, led, calc, calc2) {
		var s = symbol(id, bp);
		s.led = led || function(left) {
			this.first = left;
			this.second = expression(bp); /// bp? 따로 함수로 뺄수 있는지 확인해보자..
			this.arity = "binary";
			return this;
		};

		calc && (s.calcFn["binary"] = calc);
		calc2 && (s.calcFn["ternary"] = calc2);

		return s;
	}

	function prefix(id, nud, calc) {
		var s = symbol(id);
		s.nud = nud || prefix.nud;
		s.calcFn["unary"] = calc;
		return s;
	}
	prefix.nud = function() {
		this.first = expression(80);
		this.arity = "unary";
		return this;
	};

	constant("undefined", undefined);
	constant("null", null);
	constant("true", true);
	constant("false", false);
	constant("Infinity", Infinity);
	constant("-Infinity", -Infinity);
	constant("NaN", NaN);

	symbol(":");
	symbol(",");
	symbol(")");
	symbol("]");
	symbol("}");
	symbol("(end)");

	symbol("(name)").nud = itself;
	symbol("(name)").calcFn = {
		"name": function() {
			return $scope[this.value];
		},
		"literal": function() {
			return this.value;
		}
	};

	symbol("(literal)").nud = itself;
	symbol("(literal)").calcFn = {
		"literal": function() {
			return this.value;
		}
	};

	symbol("this").nud = function() {
		this.arity = "this";
		return this;
	};

	infix("+", 60, null, function(a, b) {
		return a.calc() + b.calc();
	});

	infix("-", 60, null, function(a, b) {
		return a.calc() - b.calc();
	});

	infix("*", 70, null, function(a, b) {
		return a.calc() * b.calc();
	});

	infix("/", 70, null, function(a, b) {
		return a.calc() / b.calc();
	});

	infix("%", 70, null, function(a, b) {
		return a.calc() % b.calc();
	});

	infix(".", 90, function(left) {
		if (token.arity !== "name") {
			error(token, "Expected a property name.");
		}
		token.arity = "literal";

		this.first = left;
		this.second = token;
		this.arity = "binary";
		advance();
		return this;

	}, function(a, b) {
		var obj = a.calc();
		return obj && obj[b.value];
	});

	infix("(", 90, function(left) {
		var a = [];
		if (left.id === "." || left.id === "[") {
			this.arity = "ternary";
			this.first = left.first;
			this.second = left.second;
			this.third = a;
		}
		else {
			this.arity = "binary";
			this.first = left;
			this.second = a;
			if ((left.arity !== "unary" || left.id !== "function")
				&& left.arity !== "name" && left.id !== "("
				&& left.id !== "&&" && left.id !== "||" && left.id !== "?") {
				error(left, "Expected a variable name.");
			}
		}

		if (token.id !== ")") {
			while(true) {
				a.push(expression(0));
				if (token.id !== ",") {
					break;
				}
				advance(",");
			}
		}

		advance(")");
		return this;

	}, function(a, b) {
		var thisObj = $scope;
		return a.calc().apply(thisObj, b.map(calc));

	}, function(a, b, c) {
//		console.log(a.calc(), b.calc(), c);
		var thisObj = a.calc();
		return thisObj[b.calc()].apply(thisObj, c.map(calc));
	});

	prefix("+", null, function(a) {
		return +a.calc();
	});

	prefix("-", null, function(a) {
		return -a.calc();
	});

	prefix("!", null, function(a) {
		return !a.calc();
	});

	prefix("(", function() {
		var e = expression(0);
		advance(")");
		return e;
	});

	prefix("[", function() {
		var array = [];
		if (token.id !== "]") {
			for(;;) {
				array.push(expression(0));
				if (token.id !== ",") {
					break;
				}
				advance(",");
			}
		}
		advance("]");
		this.first = array;
		this.arity = "unary";
		return this;

	}, function(a) {
		return a.map(calc);
	});

	function calc(token) {
		return token.calc();
	}

	// @TODO: parse는 cahce가능하게.. token도 cache가능하게 하자.
	function $parse(source) {
		tokens = tokenize(source);
		token_nr = 0;
		advance();
		var s = expression(0);
		advance("(end)");

		return function(scope) {
			$scope = scope;
			console.log(JSON.stringify(s, null, "\t"));
			return s.calc();
		}
	}

	function value(a) {
		return a.value;
	}

	var $scope = {};

	var source = "foo.bar(x)";
	var root = $parse(source);

	var scope1 = {x: 100, y: 200};
	scope1.foo = function(x) {
		return x * 2;
	};

	scope1.foo.a = 250;

	scope1.foo.bar = function(x) {
		return this.a * x;
	};

	console.log(root(scope1));
	with($scope)console.log(eval(source));


//	testOperator();

	function testOperator() {
		var a = "{ } ( ) [ ] . ; , < > <= >= == != === !== + - * % ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^= / /=";

		var script = document.getElementsByTagName("script")[0].innerText;
		var $tokens = tokenize(a);
		var b = a.split(/\s+/);

		for (var i = 0; i < 100; i++) {
			console.log($tokens[i].type, $tokens[i].value, b[i]);
		}
	}


</script>