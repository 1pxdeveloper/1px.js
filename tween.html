<style>
	#box {
		width: 100px;
		height: 100px;
		background: red;
	}
</style>

<div id="box"></div>

<script>
	function cubic_bezier(x1, y1, x2, y2, epsilon) {
		epsilon = epsilon || 1;

		var curveX = function(t) {
			var v = 1 - t;
			return 3 * v * v * t * x1 + 3 * v * t * t * x2 + t * t * t;
		};

		var curveY = function(t) {
			var v = 1 - t;
			return 3 * v * v * t * y1 + 3 * v * t * t * y2 + t * t * t;
		};

		var derivativeCurveX = function(t) {
			var v = 1 - t;
			return 3 * (2 * (t - 1) * t + v * v) * x1 + 3 * (-t * t * t + 2 * v * t) * x2;
		};

		return function(t) {

			var x = t, t0, t1, t2, x2, d2, i;

			// First try a few iterations of Newton's method -- normally very fast.
			for (t2 = x, i = 0; i < 8; i++) {
				x2 = curveX(t2) - x;
				if (Math.abs(x2) < epsilon) return curveY(t2);
				d2 = derivativeCurveX(t2);
				if (Math.abs(d2) < 1e-6) break;
				t2 = t2 - x2 / d2;
			}

			t0 = 0;
			t1 = 1;
			t2 = x;

			if (t2 < t0) return curveY(t0);
			if (t2 > t1) return curveY(t1);

			// Fallback to the bisection method for reliability.
			while(t0 < t1) {
				x2 = curveX(t2);
				if (Math.abs(x2 - x) < epsilon) return curveY(t2);
				if (x > x2) t0 = t2;
				else t1 = t2;
				t2 = (t1 - t0) * .5 + t0;
			}

			// Failure
			return curveY(t2);
		};
	}


	window.Tween = function() {

//		var requestAnimationFrame = typeof requestAnimationFrame === "undefined" ? setTimeout : requestAnimationFrame;
//		var cancelAnimationFrame = typeof cancelAnimationFrame === "undefined" ? setTimeout : cancelAnimationFrame;

		var timestamp = function() {
			if (typeof performance && window.performance.now) {
				return function() {
					return window.performance.now();
				}
			}

			return function() {
				return +new Date();
			}
		}();

		var ease;
		ease = cubic_bezier(.25, 1, .25, 1);
//		ease = cubic_bezier(0, 0, .58, 1, 1);
//		ease = cubic_bezier(.42, 0, .58, 1);

		function render(startTime, begin, by, duration, update, resolve, reject) {
			var t = (timestamp() - startTime) / duration;
			if (t >= 1) {
				update(begin + by, t);
				resolve(begin + by);
				return;
			}

			var value = begin + ease(t) * by;

			var result = update(value, t);
			if (result === false || update.returnValue === false) {
				reject(begin + by);
				return;
			}

			requestAnimationFrame(function() {
				render(startTime, begin, by, duration, update, resolve, reject);
			});
		}

		return {
			to: function(from, to, duration, update, id) {
				var promise = new Promise(function(resolve, reject) {
					var by = to - from;
					render(timestamp(), from, by, duration, update, resolve, reject);
				});

				promise.cancel = function() {
					update.returnValue = false;
				};

				return promise;
			}
		}
	}();


	function easing(duration, fn) {

		var timestamp = function() {
			if (typeof performance && window.performance.now) {
				return function() {
					return window.performance.now();
				}
			}

			return function() {
				return +new Date();
			}
		}();

		function render() {

		}

		render();
	}

	var d = document.getElementById("box");

	document.onclick = function() {
		Tween.to(0, 250, 1000, function(value, t) {
			if (value > 100) {
				return false;
			}

			d.style["-webkit-transform"] = "translate3d(" + value + "px,0,0)";
		}, "move").then(function() {

		}).catch(function() {
			alert("stop!");

		});

	};



</script>