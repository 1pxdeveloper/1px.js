<style>
	#box {
		width: 100px;
		height: 100px;
		background: red;
	}
</style>

<div id="box"></div>

<script>
	function cubic_bezier(x1, y1, x2, y2, epsilon) {
		epsilon = epsilon || 1;

		var curveX = function(t) {
			var v = 1 - t;
			return 3 * v * v * t * x1 + 3 * v * t * t * x2 + t * t * t;
		};

		var curveY = function(t) {
			var v = 1 - t;
			return 3 * v * v * t * y1 + 3 * v * t * t * y2 + t * t * t;
		};

		var derivativeCurveX = function(t) {
			var v = 1 - t;
			return 3 * (2 * (t - 1) * t + v * v) * x1 + 3 * (-t * t * t + 2 * v * t) * x2;
		};

		return function(t) {

			var x = t, t0, t1, t2, x2, d2, i;

			// First try a few iterations of Newton's method -- normally very fast.
			for (t2 = x, i = 0; i < 8; i++) {
				x2 = curveX(t2) - x;
				if (Math.abs(x2) < epsilon) return curveY(t2);
				d2 = derivativeCurveX(t2);
				if (Math.abs(d2) < 1e-6) break;
				t2 = t2 - x2 / d2;
			}

			t0 = 0;
			t1 = 1;
			t2 = x;

			if (t2 < t0) return curveY(t0);
			if (t2 > t1) return curveY(t1);

			// Fallback to the bisection method for reliability.
			while(t0 < t1) {
				x2 = curveX(t2);
				if (Math.abs(x2 - x) < epsilon) return curveY(t2);
				if (x > x2) t0 = t2;
				else t1 = t2;
				t2 = (t1 - t0) * .5 + t0;
			}

			// Failure
			return curveY(t2);
		};
	}

	var timestamp = function() {
		if (typeof performance && window.performance.now) {
			return function() {
				return window.performance.now();
			}
		}

		return function() {
			return +new Date();
		}
	}();


	function render(ease, startTime, duration, update, resolve, reject) {
		var t = (timestamp() - startTime) / duration;
		if (t >= 1) {
			update(1);
			return resolve(1);
		}

		var factor = ease(t);
		var result = update(factor);
		if (result === false || update.returnValue === false) {
			reject(factor);
			return;
		}

		requestAnimationFrame(function() {
			render(ease, startTime, duration, update, resolve, reject);
		});
	}

	function easing(duration, update) {
		var ease = cubic_bezier(0.25, 1, 0.25, 1);
		var promise = new Promise(function(resolve, reject) {
			render(ease, timestamp(), duration, update, resolve, reject);
		});
		return promise;
	}

	function parseTransform(element) {
		var computedStyle = window.getComputedStyle(element, null); // "null" means this is not a pesudo style.
		var matrix = computedStyle.getPropertyValue('transform')
				|| computedStyle.getPropertyValue('-moz-transform')
				|| computedStyle.getPropertyValue('-webkit-transform')
				|| computedStyle.getPropertyValue('-ms-transform')
				|| computedStyle.getPropertyValue('-o-transform');

		// Parse this string to obtain different attributes of the matrix.
		// This regexp matches anything looks like this: anything(1, 2, 3, 4, 5, 6);
		// Hence it matches both matrix strings:
		// 2d: matrix(1,2,3,4,5,6)
		// 3d: matrix3d(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16);
//		var matrixPattern = /^\w*\((((\d+)|(\d*\.\d+)),\s*)*((\d+)|(\d*\.\d+))\)/i;
//		var matrixValue = [];
//		if (matrixPattern.test(matrix)) { // When it satisfy the pattern.
//			var matrixCopy = matrix.replace(/^\w*\(/, '').replace(')', '');
//			console.log(matrixCopy);
//			matrixValue = matrixCopy.split(/\s*,\s*/);
//
//			console.log(matrixValue);
//		}

		var a = matrix.match(/\([^)]*\)/);

		console.log(a);

		if (a) {
			var values = a[0];

			/// 2d
			if (matrix.indexOf("matrix(") >= 0) {
				values = values.slice(1, -1).split(/\s*,\s*/);
				return {
					x: +values[4],
					y: +values[5]
				}
			}

			/// 3d
			if (matrix.indexOf("matrix3d(") >= 0) {
				values = values.slice(1, -1).split(/\s*,\s*/);
				return {
					x: +values[12],
					y: +values[13]
				}
			}

			return;
		}
		return {
			x: 0,
			y: 0
		};
	}

	function moveTo(duration, params) {
		return function(el) {
			var transform = parseTransform(el);
			var startX = transform.x;
			var startY = transform.y;
			params.x = params.x || transform.x;
			params.y = params.y || transform.y;

			return easing(duration, function(factor) {
				var x = startX + ((params.x - startX) * factor) + "px";
				var y = startY + ((params.y - startY) * factor) + "px";
				el.style["-webkit-transform"] = "translate3d(" + x + "," + y + ", 1px)";
			});
		}
	}

	function fadeOut(duration) {
		return function(el) {
			var opacity = +getComputedStyle(el)["opacity"] || 1;
			return easing(duration, function(factor) {
				el.style.opacity = opacity + ((0 - opacity) * factor);
			});
		}
	}

	function fadeIn(duration) {
		return function(el) {
			var opacity = +getComputedStyle(el)["opacity"] || 0;
			return easing(duration, function(factor) {
				el.style.opacity = opacity + ((1 - opacity) * factor);
			});
		}
	}


	//	function fadeOut(el, duration) {
	//		return easing(duration, function(factor) {
	//			el.style["opacity"] = 1 - factor;
	//		});
	//	}

	function run(el, action) {
		return Promise.resolve(action(el));
	}

	var Action = {
		create: function() {},
		run: run,
		moveTo: moveTo,
		fadeIn: fadeIn,
		fadeOut: fadeOut,
		delay: function() {}
	};

	var d = document.getElementById("box");
	d.style.opacity = 0.5;
	d.style["-webkit-transform"] = "translate3d(0,50px,1px)";

	var flag = false;

	function Animation() {

	}

	Animation.prototype = {
		sequence: function(el) {
			this.el = el;
			return this;
		},

		end: function() {
			return this;
		},

		spwan: function(el) {
			this.el = el;
			return this;
		},

		delay: function() {
			return this;
		},

		moveTo: function(duration, params) {
			return this;
		},

		fadeTo: function(duration, params) {
			return this;
		},

		fadeIn: function(duration, params) {
			return this.fadeTo(1);
		},

		fadeOut: function(duration, params) {
			return this.fadeTo(0);
		}
	};

	document.onclick = function(e) {

		var x = 0;
		var y = 0;

//		var action = Action.create([fadeIn(1000), moveTo(500, {x: 100, y: 200})]);
////		action.run(d);
//
//		Action.create(d).fadeIn(1000).moveTo(500, {x: 100, y: 200});
//
//		Action.queue().fadeIn(1000).moveTo(500, {x: 100, y: 200});
//

//		var a = new Animation()
//				.sequence(box).fadeIn(1000).delay(500).moveTo(20, 100)
//					.spwan(box2)
//						.moveTo(500, {x: 100, y: 200})
//						.fadeIn(100)
//						.begin().sequence(box3).fadeIn(1000).delay(500).moveTo(20, 100).end()
//						.fadeIn(100)
//						.begin().sequence(box4).fadeIn(1000).delay(500).moveTo(20, 100).end()
//						.fadeIn(100)
// 				.run();


//		var b = Action.spwan().fadeIn(1000).moveTo(500, {x: 10, y: 20});


//		Action.run(d, fadeIn(1000))
//				.then(function() {
//					return Action.run(d, Action.moveTo(1000, {x: e.pageX, y: e.pageY }))
//				})
//				.then(function() {
//					Action.run(d, fadeOut(1000))
//				});

//		fadeOut(d, 2000);

	};


</script>