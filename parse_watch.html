<meta charset="utf-8"/>

<div id="output"></div>

<pre>
<section>x</section>
<section>foo.a</section>
<section>foo.x</section>
<section>x + foo.x + x</section>
<section>x === foo.x</section>
<section>x === foo.bar.x</section>
<section>foo(x)</section>
</pre>


<script src="new/watchtower.js"></script>
<script src="new/parse.js"></script>
<script>


/*
@TODO: parse.js에서 $watch로 거는 개별 콜백이 동일한 형태(self.uncahce) 이므로 callbacks를 제거할 수 있다.
 @TODO: self.path를 생성하는 과정에서 old_path를 체크할수 있고 map삭제가 가능하다는 것을 의미한다.
 @TODO: self.path를 생성하는 과정에서 {path: token} 형태의 테이블을 생성하고 new path에 대해서 uncache()하는 형태로 callback을 제거한다.
 @TODO: map, {path:token}, $scope를 한 큐에 처리하는 방법을 고민한다.
 @TODO: [$scope, $scope, $scope, $local] 등의 $scope Stack을 처리하는 방법을 고민 할 것!

*/
	function foreach(arr, fn) {
		for(var i = 0, len = arr.length; i < len; i++) {
			fn(arr[i], i);
		}
	}

	function value(a) {
		return a.value;
	}


	var $scope = {x: 100, y: 200};
	$scope.foo = function(x) {
		return x * 2;
	};

	$scope.foo.a = 250;
	$scope.foo.x = "bar";
	$scope.foo.bar = {};
	$scope.foo.bar.a = 3000;

	$scope.foo.baz = {};
	$scope.foo.baz.a = 300;




	var map = {};

	var els = document.querySelectorAll("section");
	foreach(els, function(el) {
		var fn = $parse(el.innerText);
		var textNode = document.createTextNode("");
		el.appendChild(textNode);

		/// @TODO: map과 $scope를 한번에 같이 정의하는 형태로 가져간다.
		var scope = $watchTower(map, function() {
			console.log("$update()");
			var ret = fn(scope);
			textNode.nodeValue = " : " + ret;
		});

		scope.$scope = $scope;

		fn(scope);
	});


//	setInterval(function() {
//		scope1.foo.bar.a++;
//	}, 1000);


//	console.log(ret);
//
//	scope1.x = 4000;
//
//	ret = fn(scope1);
//	console.log(ret);
//
//	ret = fn(scope1);
//	console.log(ret);
//
//
//	function test() {
//		scope1.x = 500;
//		scope1.foo.a = 200;
//	}


/*

callback이 같으면 한 Quque에 돌릴까?

 */
//	console.log(ret);


</script>