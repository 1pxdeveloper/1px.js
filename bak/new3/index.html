<h1 [inner-html]="'Hello'" [disabled]="false" [id]="def"></h1>

<div>
	<div repeat="rows as row" @title="hello">
		<h1>hello, <span html="abcd"></span></h1>
		<h2 repeat="test">test <span html="ddd"></span> </h2>
	</div>

	<div>Asdklfaskldfasfd</div>
</div>


<script>
// @TODO: name을 확인해서 아래와 같이 UNDEFINED로 만들어서 Reference Error를 처리하고, UNDEFINED일 경우에서는 undefined를 리턴하자.
var UNDEFINED = {};
UNDEFINED.abc = UNDEFINED;
UNDEFINED.def = UNDEFINED;
UNDEFINED.x = UNDEFINED;


function noop(){}

function foreach(object, fn) {
	fn = fn || noop;
	for (var i = 0, len = object.length; i < len; i++) {
		fn(object[i], i);
	}
}

function makeArray(arr) {
	if (!arr) return [];

	var i = arr.length, result = Array(i);
	while(i-- !== 0) {
		result[i] = arr[i];
	}
	return result;
}

function $eval(script, scope, thisObj) {
	var fn = $eval.$cache[script] = $eval.$cache[script] || new Function("with(arguments[0])return " + script);

	try {
		return fn.call(thisObj, scope);
	}
	catch(e) {

	}
}
$eval.$cache = {};



function $travarsal(node, fn, fn2, data) {
	fn = fn || noop;
	fn2 = fn2 || noop;

	var stack = [];
	var ret;
	var nextSibling;

	if (fn(node, data) === false) {
		return;
	}
	node = node.firstChild;

	while(node) {

		nextSibling = node.nextSibling;
		ret = fn(node, data);
		stack.push(node);

		if (node.parentNode && node.firstChild && ret !== false) {
			node = node.firstChild;
			continue;
		}

		while(node = stack.pop()) {
			nextSibling = node.nextSibling || nextSibling;
			fn2(node, data);

			if (nextSibling) {
				node = nextSibling;
				nextSibling = null;
				break;
			}
		}
	}
}

function attributesOf(el) {
	return makeArray(el.attributes);
}

function $compile(el) {
	$travarsal(el, $compile_process);
}

function $compile_process(node) {
	if (node.nodeName === "SCRIPT" || node.nodeName === "STYLE") {
		return false;
	}

	if (node.nodeType === 1) {
		return $compile_element(node);
	}
}

function $compile_element(el) {

	var bindings = [];

	var attrs = attributesOf(el);

	foreach(attrs, function(attr) {

		var attrName = attr.name;
		var attrValue = attr.value;

//		var prefix = attrName.charAt(0);
//		if (prefix === "@") {
//			var prop = attrName.slice(1);
//			el[prop] = attrValue;
//		}

		var directive = $$directive[attrName];
		if (!directive) {
			return;
		}

		if (directive.init) {
			directive.init(el);
		}

		bindings.push(directive);
	});

	if (bindings.length) {
		el.$update = function(el, scope) {
			foreach(bindings, function(binding) {
				binding.update(el, scope);
			})
		}
	}
}

function $watch(el, script, fn) {
	el.$watchers = el.$watchers || [];

	var w = {};
	w.script = script;
	w.fn = fn;

	el.$watchers.push(w);
}

function $watch2(el, scope, fn) {
//	el.$watchers = el.$watchers || [];
//
//	var w = {};
//	w.script = script;
//	w.fn = fn;
//
//	el.$watchers.push(w);

	foreach(scope, function(expr) {
		var prefix = expr.charAt(0);

		// attr interpolate check
		if (prefix === "@") {
			return;
		}

		// attr value check
		if (prefix === "=") {
			return;
		}

		// function check
		if (prefix === "&") {
			return;
		}

		// value check

	});
}


var $$directive = {

	"repeat": {
		init: function(el) {

			var placeholderStart = document.createComment("repeat");
			var placeholderEnd = document.createComment("end");
			var $repeatNode = el.cloneNode(true);
			$repeatNode.removeAttribute("repeat");

			el.parentNode.insertBefore(placeholderStart, el);
			el.parentNode.insertBefore(placeholderEnd, el);
			el.parentNode.removeChild(el);
		},

		update: function(scope, el) {
			console.log(el);
		}
	},

	"html": {
		init: function(el) {
			el.innerHTML = "";
		},

		update: function(scope, el) {

			console.log(el, scope);

			el.innerHTML = scope.rows;
		}
	}
};






function $update(el, $scope) {
	$travarsal(el, $update_process, noop, $scope);
}

function $update_process(el, $scope) {
	el.$update && el.$update($scope, el);
}


var scope = {};
scope.rows = [1,2,3,4,5];

$compile(document.body);
$update(document.body, scope);
</script>






